pyinstaller build.spec --clean

TRY-311025-415104529d29e81
PRO-311025-9af55a77cb702a2
DEV-311025-37c5b95d5adeb5b
ticket = PRO-181025-b2d2d9472fe07a0


НОВОЕ (АВТО ПОЛЕТ, СМОТРИМ СТАТУС И ЕСЛИ ЧТО ОТПРАВЛЯЕМ КОМУ ПОЛЕТ НАЖАТЬ)
вызвать дважды пробелы
Хендхантер ломает ахк после (хоткеи не работают)



1. Тригер с медитации (space - tp - space)
2. Привязка всех действий к группе, (лидера не проверять)
3. Сохранять REDO (Вместо EXIT) не тратит лимиты
4. Увеличить лимиты до 200, 100
5. Талон на снятие лимитов (до завтра) например PRO месячный ключ и PRO талон на сегодня без лимитов, его нужно проверять только когда лимит уже достигнут, до лимитов все работает отлично
6. Ломается хедхантер, иногда после выключения ахк перестает принимать сигралы
7. Куб (прогрузочная комната), возьмем логику NEXT



! На будущее
статус персонажа медитации смотреть
авто асист и тригером на боссов и проверкой чи

















=== Лицензионные ключи (TRY) ===

1 Pawka: TRY-311025-415104529d29e81
2 Sawka: TRY-311025-42d33e2392167ce
3 Evgen: TRY-311025-63f3a6cd8b3df64
4 Wladik: TRY-311025-6527dcfa0d5c656
5 Valek: TRY-311025-a3ce7b192d6e5ea
6 Sergey: TRY-311025-4df6a0dd9cc9324
7 Ruzlan: TRY-311025-720807f3818d212

=== Лицензионные ключи (PRO) ===

1 Pawka: PRO-311025-9af55a77cb702a2
2 Sawka: PRO-311025-d295e43143608a2
3 Evgen: PRO-311025-ab1479c1c54cffa
4 Wladik: PRO-311025-bc520fe35954914
5 Valek: PRO-311025-386f0ce8aa80c33
6 Sergey: PRO-311025-49b58b8f46d9a55
7 Ruzlan: PRO-311025-edda40f4b3bcd41

=== Лицензионные ключи (DEV) ===

1 Pawka: DEV-311025-37c5b95d5adeb5b
2 Sawka: DEV-311025-13d9b8a7a1a759b
3 Evgen: DEV-311025-983dcb1c7ca8f4d
4 Wladik: DEV-311025-81a2b978a93442a
5 Valek: DEV-311025-f8a9d544eee7135
6 Sergey: DEV-311025-420f808ddfb0edb
7 Ruzlan: DEV-311025-6ecde2f6bd163f1

=== Талон на 1 день (PRO) ===
Ticket (expires 161025): PRO-161025-e6c6f4e7a539973

=== Проверка ключа ===
Generated key: PRO-311025-9af55a77cb702a2
Результат: True, Уровень: pro, Сообщение: OK
=== Тест талонов ===

Просроченный ключ (вчера 161025): PRO-161025-e6c6f4e7a539973
Результат: True, Уровень: pro, Сообщение: OK

Талон на сегодня: PRO-181025-bf1fdbff500a8f3
Результат: True, Уровень: pro, Сообщение: OK

Талон на завтра: PRO-191025-831210671a7bb43
Результат: True, Уровень: pro, Сообщение: OK












-------------------
Берем текущее окно, проверяем есть ли пати, если есть берем их с собой

Фоллов записываем все состояния полетов для окон и храним в кеше для каждого чар идем и состояние










1. ElementClient.exe +0x5D1D89
    a1: 0000027D73548EC0 [charorigin +0x50] "rcx"
    a2: 0000027D1ECC1B60 [charbase] "rdx"

char __fastcall sub_7FF787271D89(__int64 a1, __int64 a2)
{
  char v2; // zf

  if ( v2 )
    return sub_7FF786CB2FA8(a1, a2);
  else
    return 0;
}

2. ElementClient.exe +0x12FA8

char __fastcall sub_7FF786CB2FA8(__int64 a1, __int64 a2)
{
  return sub_7FF787272320(a1, a2);
}

3. ElementClient.exe +0x5D2320

    char __fastcall sub_7FF787272320(__int64 a1, __int64 a2)
    {
    _UNKNOWN ***v3; // rcx
    _UNKNOWN **v5; // r14
    __int64 v6; // rsi
    __int64 v7; // rdi
    __int64 v8; // rdx
    __int64 v9; // r8
    __int64 v10; // r9
    unsigned int v11; // r10d
    __int64 v12; // rdx
    int v13; // eax
    _BOOL8 v14; // rdi
    int v15; // eax
    int v17; // [rsp+28h] [rbp-40h]

    v3 = off_7FF7880C8CE8;
    v5 = off_7FF7880C8CE8[7];
    v6 = *(int *)(*(_QWORD *)(a1 + 8) + 24LL);
    if ( v6 > 0 )
    {
        v7 = 0;
        do
        {
        v8 = v7 + *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16LL);
        v9 = (unsigned int)*(__int16 *)(v8 + 16);
        v10 = (unsigned int)*(__int16 *)(v8 + 18);
        v11 = *(_DWORD *)(v8 + 24);
        switch ( *(_DWORD *)v8 )
        {
            case 0x200:
            sub_7FF786CAF55B(a1, a2, v9, v10, v11, *(_QWORD *)(v8 + 8));
            break;
            case 0x201:
            sub_7FF786CA5600(a1, a2, v9, v10, v11);
            break;
            case 0x202:
            sub_7FF786CDDD02(a1, a2, v9, v10, v11);
            break;
            case 0x203:
            sub_7FF786CBFAB4(a1, a2, v9, v10, v11);
            break;
            case 0x204:
            sub_7FF786CD85AA(a1, a2, v9, v10, v11);
            break;
            case 0x205:
            sub_7FF786CAFF33(a1, a2, v9, v10, v11, v17);
            break;
            case 0x206:
            sub_7FF786CA9228(a1, a2, v9, v10, v11);
            break;
            case 0x207:
            sub_7FF786CAFB2D(a1, a2, v9, v10, v11);
            break;
            case 0x20A:
            v17 = *(unsigned __int16 *)(v8 + 8);
            sub_7FF786CA686B(a1, a2, v9, v10, *(__int16 *)(v8 + 10));
            break;
            default:
            break;
        }
        v7 += 32;
        --v6;
        }
        while ( v6 );
        v3 = off_7FF7880C8CE8;
    }
    v12 = *(unsigned __int8 *)(a1 + 48);
    if ( (_BYTE)v12 || *(_BYTE *)(a1 + 68) )
    {
        if ( !*(_BYTE *)(a2 + 4761) && !*(_BYTE *)(a2 + 4760) )
        {
        v13 = *(_DWORD *)(a1 + 16);
        v14 = (_BYTE)v12 != 0;
        if ( v13 )
            sub_7FF786CBC940((_DWORD)v5, 223, 0, 0, -v13, 0, v14, 0, 0);
        v15 = *(_DWORD *)(a1 + 20);
        if ( v15 )
            sub_7FF786CBC940((_DWORD)v5, 222, 0, 0, -v15, 0, v14, 0, 0);
        }
        *(_QWORD *)(a1 + 16) = 0;
        v3 = off_7FF7880C8CE8;
        if ( *((_BYTE *)off_7FF7880C8CE8[2] + 72) )
        {
        v12 = 0;
        goto LABEL_27;
        }
    }
    else if ( !*((_BYTE *)v3[2] + 72) )
    {
        LOBYTE(v12) = 1;
    LABEL_27:
        sub_7FF786CE11E1(v3, v12);
    }
    return 1;
    }
    
4. ElementClient.exe +0x5600

    __int64 __fastcall sub_7FF786CA5600(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5)
    {
    return sub_7FF787271190(a1, a2, a3, a4, a5);
    }

5. ElementClient.exe +0x5D1190
    a3: 376 [ElementClient.exe+146F4B8] "r8" HEX mouse coord (меняется от 000 до 77F)
    a4: 40D координата мышки [ElementClient.exe+146F4BC] "r9" HEX mouse coord (меняется от 000 до 40F)
    a5: 0 [можно не считать, всегда равен 0] "rbp+28"

    __int64 __fastcall sub_7FF787271190(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5)
    {
    __int64 v5; // rsi
    __int64 v7; // rbp
    __int64 result; // rax

    v5 = a4;
    v7 = a3;
    *(_BYTE *)(a1 + 32) = 1;
    result = sub_7FF786CD061B();
    *(_DWORD *)(a1 + 36) = result;
    *(_BYTE *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 40) = v7;
    *(_DWORD *)(a1 + 44) = v5;
    if ( !*(_BYTE *)(a2 + 4761) && !*(_BYTE *)(a2 + 4760) )
        return sub_7FF786CBC940((unsigned int)off_7FF7880C8CE8[7], 224, 0, 0, v7, v5, a5, 0, 0);
    return result;
    }


sub_7FF787203290 преобразует корды?






Помоги собрать новую логику для экшенов.

У нас есть глобальная перепроверка на доступ по ключу, но запускается она только обновлением персонажей, я хочу добавить в базовые функции телепорта и в самый конец, что бы не замедлять работу, респонс на проверку даты, и если срок действия итек, то запустить рефреш принудительно, он уже сам перезагрузит гуи и спрячет функционал.

Так же нужен инструмент, который будет создавать лимит использований экшенов, и проверять/записывать в конце экшенов. А в начале должна быть быстрая проверка кеш значения. Нужен счетчик для каждого использования NEXT и LONG (одна переменная и для двух экшенов) и для QBSO QBGO (тоже одна на оба экшена). В начале экшена будет проверка лимита, а в конце счетчик++ и если он привысил ограничения, то кешированное значение в фолс. Кол-во заходов, обе переменные, удобно будет разместить в константах. А проверять, сколько заходов сделано, мы будем из логов. В виде счетчика будем использовать функцию, которая читает логи (которые мы храним в аппдата) и собирает информацию за последний день, и выводит по дням, типо 13.10 TP сделано 10 из 10, QB сделано 3 из 10. Счетчик можно обновлять в функции рефреш. Когда наступит 00 по МСК в любой из проверок времени, можно обновить переменные счетчика если они уперлись в лимит, или может ты лучше придумаешь способ.

get_leader_and_group усложнен. Достаточно взять последнего активного персонажа, и если он в пати, вернуть всех членов группы, которые мы получим через офсеты, иначе вернуть только себя. Групповыми экшанами можно будет пользоваться и без наличия группы с таким новым подходом.

Пришла идея хранить мапу для pid & char_id, поможет легко найдя всю свою группу, потом по id вызывать функции AHK. Обновлять мапу можно вместе с рефрешем.

Экшен следовать. Раньше он котролировал высоту, сейчас перестал работать. Должен работать только для окон, которые находятся в пати, в одной локации, и только если среди них есть лидер. Логика есть в менеджере, но сейчас не работает. Так же у каждого чара помимо флай статуса есть тригер полета, записав значение в который можно встать на полет или упасть с него. Там 2 уникальных состояния, которые нужно хранить в сеттингс.джейсон и обновлять при рефреше. fly int: charbase -> +0xA58. Для моего персонажа например летать 536913936, не летать 536913920. Локацию нужно проверять для окон каждый раз прежде чем морозить, что бы исключить, что оно в другой локации от лидера летает. Лидеру группы никогда не морозим значения и не меняет значения полета.

Экшен атаковать, тоже не работает, что то не так со связью с офсетами. Может быть и 5 пункт из за этого сломался. 

Экшен хедхантер тоже активируется и ничего не делает, может быть общая проблема тогл экшенов. Главное что бы он к активному окну начал работать и продолжал даже когда я начну играть в другом окне.

Таргет телепорт работает отлично.

Лонги, екзит, qb работают отлично, только добавить лимиты вызовов.










Теперь можно попробовать вызвать функцию передвижения (пока для примера пусть это будут координаты таргета).

1. ElementClient.exe +0x5D2320

    a1 0000027D73548EC0 [charorigin +0x50] "rcx"
    a2 0000027D1ECC1B60 [charbase] "rdx"

    char __fastcall sub_7FF787272320(__int64 a1, __int64 a2)
    
2. ElementClient.exe +0x5600

    a1: 0000027D73548EC0 [charorigin +0x50] "rcx"
    a2: 0000027D1ECC1B60 [charbase] "rdx"
    a3: 376 [ElementClient.exe+146F4B8] "r8" HEX mouse coord (меняется от 000 до 77F)
    a4: 40D координата мышки [ElementClient.exe+146F4BC] "r9" HEX mouse coord (меняется от 000 до 40F)
    a5: 0 [можно не считать, всегда равен 0] "rbp+28"

    __int64 __fastcall sub_7FF786CA5600(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5)
    {
        return sub_7FF787271190(a1, a2, a3, a4, a5);
    }

3. ElementClient.exe +0x5D1190

    __int64 __fastcall sub_7FF787271190(__int64 a1, __int64 a2, int a3, int a4, unsigned int a5)

Не забудь сначала поменять, а потом заморозить координаты movepoint_x, y, x на время выполнения последней функции.








; Команда: attack_guard
if (command = "attack_guard")
{
    ReadSettings()
    
    offset_x := leader_x + 30
    assist_y := leader_y + 65
    
    WinGet, windows, List, ahk_exe ElementClient.exe
    Loop, %windows%
    {
        hwnd := windows%A_Index%
        WinGet, window_pid, PID, ahk_id %hwnd%
        if (window_pid != excluded_windows) && WinExist("ahk_id " . hwnd) {
            ; ПКМ по лидеру
            ControlClick, x%leader_x% y%leader_y%, ahk_id %hwnd%, , R, NA
            Sleep, 50
            ; ЛКМ ассист
            ControlClick, x%offset_x% y%assist_y%, ahk_id %hwnd%, , L, NA
            Sleep, 50
            ; ЛКМ макрос guard
            ControlClick, x%macros_spam_x% y%macros_spam_y%, ahk_id %hwnd%, , L, NA
        }
    }
    FileDelete, %CommandFile%
    return
}

; Команда: attack_boss
if (command = "attack_boss")
{
    ReadSettings()
    
    offset_x := leader_x + 30
    assist_y := leader_y + 65
    
    WinGet, windows, List, ahk_exe ElementClient.exe
    Loop, %windows%
    {
        hwnd := windows%A_Index%
        WinGet, window_pid, PID, ahk_id %hwnd%
        if (window_pid != excluded_windows) && WinExist("ahk_id " . hwnd) {
            ; ПКМ по лидеру
            ControlClick, x%leader_x% y%leader_y%, ahk_id %hwnd%, , R, NA
            Sleep, 50
            ; ЛКМ ассист
            ControlClick, x%offset_x% y%assist_y%, ahk_id %hwnd%, , L, NA
            Sleep, 50
            ; ЛКМ макрос boss
            ControlClick, x%macro_boss_x% y%macro_boss_y%, ahk_id %hwnd%, , L, NA
        }
    }
    FileDelete, %CommandFile%
    return
}

ReadSettings() {
    global leader_x, leader_y, macros_spam_x, macros_spam_y, macro_boss_x, macro_boss_y
    
    IniRead, leader_x, %SettingsFile%, Coordinates, leader_x, 960
    IniRead, leader_y, %SettingsFile%, Coordinates, leader_y, 540
    IniRead, macros_spam_x, %SettingsFile%, Coordinates, macros_spam_x, 1300
    IniRead, macros_spam_y, %SettingsFile%, Coordinates, macros_spam_y, 850
    IniRead, macro_boss_x, %SettingsFile%, Coordinates, macro_boss_x, 1350
    IniRead, macro_boss_y, %SettingsFile%, Coordinates, macro_boss_y, 850
}